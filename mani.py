{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ddc7ee51-4758-4000-9897-b33cdcf0281a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean: 5.5\n",
      "Standard Deviation: 2.8722813232690143\n",
      "Factorial of 5: 120\n",
      "Sine of 0.5: 0.479425533234127\n",
      "Cosine of 0.5: 0.8775824652777777\n",
      "Logarithm of 10: 2.3028502082467206\n",
      "Normal Distribution: [-1.7320730452674897, -1.4928497942386831, -1.2536265432098765, -1.01440329218107, -0.7751800411522634]\n",
      "Hypothesis Function: [3.5, 7.5]\n"
     ]
    }
   ],
   "source": [
    "from typing import List\n",
    "\n",
    "class Mani:\n",
    "    def __init__(self, data: List[float]):\n",
    "        self.data = data\n",
    "    \n",
    "    # Matrix Operations\n",
    "    @staticmethod\n",
    "    def matrix_multiply(A: List[List[float]], B: List[List[float]]) -> List[List[float]]:\n",
    "        rows_A, cols_A = len(A), len(A[0])\n",
    "        rows_B, cols_B = len(B), len(B[0])\n",
    "        result = [[0] * cols_B for _ in range(rows_A)]\n",
    "        for i in range(rows_A):\n",
    "            for j in range(cols_B):\n",
    "                result[i][j] = sum(A[i][k] * B[k][j] for k in range(cols_A))\n",
    "        return result\n",
    "    \n",
    "    @staticmethod\n",
    "    def matrix_inverse(A: List[List[float]]) -> List[List[float]]:\n",
    "        n = len(A)\n",
    "        identity = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n",
    "        for i in range(n):\n",
    "            factor = 1.0 / A[i][i]\n",
    "            for j in range(n):\n",
    "                A[i][j] *= factor\n",
    "                identity[i][j] *= factor\n",
    "            for k in range(n):\n",
    "                if k != i:\n",
    "                    factor = A[k][i]\n",
    "                    for j in range(n):\n",
    "                        A[k][j] -= factor * A[i][j]\n",
    "                        identity[k][j] -= factor * identity[i][j]\n",
    "        return identity\n",
    "    \n",
    "    # Statistical Operations\n",
    "    @staticmethod\n",
    "    def mean(data: List[float]) -> float:\n",
    "        return sum(data) / len(data)\n",
    "    \n",
    "    @staticmethod\n",
    "    def median(data: List[float]) -> float:\n",
    "        n = len(data)\n",
    "        sorted_data = sorted(data)\n",
    "        mid = n // 2\n",
    "        return sorted_data[mid] if n % 2 else (sorted_data[mid - 1] + sorted_data[mid]) / 2\n",
    "    \n",
    "    @staticmethod\n",
    "    def standard_deviation(data: List[float]) -> float:\n",
    "        mean_val = Mani.mean(data)\n",
    "        return (sum((x - mean_val) ** 2 for x in data) / len(data)) ** 0.5\n",
    "    \n",
    "    # Correlation and Covariance\n",
    "    @staticmethod\n",
    "    def correlation(x: List[float], y: List[float]) -> float:\n",
    "        mean_x, mean_y = Mani.mean(x), Mani.mean(y)\n",
    "        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n",
    "        denominator = (sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y)) ** 0.5\n",
    "        return numerator / denominator\n",
    "    \n",
    "    @staticmethod\n",
    "    def covariance(x: List[float], y: List[float]) -> float:\n",
    "        mean_x, mean_y = Mani.mean(x), Mani.mean(y)\n",
    "        return sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y)) / len(x)\n",
    "    \n",
    "    # Probability Distributions\n",
    "    @staticmethod\n",
    "    def uniform_distribution(low: float, high: float, size: int) -> List[float]:\n",
    "        scale = high - low\n",
    "        return [(low + scale * ((i * 9301 + 49297) % 233280) / 233280) for i in range(size)]\n",
    "    \n",
    "    @staticmethod\n",
    "    def poisson_distribution(lam: float, size: int) -> List[int]:\n",
    "        return [int(-((1.0 - ((i * 9301 + 49297) % 233280) / 233280)) / lam) for i in range(size)]\n",
    "    \n",
    "    @staticmethod\n",
    "    def normal_distribution(mean: float, std_dev: float, size: int) -> List[float]:\n",
    "        return [mean + std_dev * (((i * 9301 + 49297) % 233280) / 233280 - 0.5) * 6 for i in range(size)]\n",
    "    \n",
    "    # Hypothesis Function\n",
    "    @staticmethod\n",
    "    def hypothesis(theta: List[float], X: List[List[float]]) -> List[float]:\n",
    "        return [sum(theta[j] * X[i][j] for j in range(len(theta))) for i in range(len(X))]\n",
    "    \n",
    "    # Optimization (Gradient Descent)\n",
    "    @staticmethod\n",
    "    def gradient_descent(X: List[List[float]], y: List[float], learning_rate=0.01, iterations=1000) -> List[float]:\n",
    "        m, n = len(X), len(X[0])\n",
    "        theta = [0] * n\n",
    "        for _ in range(iterations):\n",
    "            gradient = [0] * n\n",
    "            for i in range(m):\n",
    "                error = sum(X[i][j] * theta[j] for j in range(n)) - y[i]\n",
    "                for j in range(n):\n",
    "                    gradient[j] += (2/m) * X[i][j] * error\n",
    "            for j in range(n):\n",
    "                theta[j] -= learning_rate * gradient[j]\n",
    "        return theta\n",
    "    \n",
    "    # Scientific Calculations\n",
    "    @staticmethod\n",
    "    def power(base: float, exponent: float) -> float:\n",
    "        result = 1.0\n",
    "        for _ in range(int(exponent)):\n",
    "            result *= base\n",
    "        return result if exponent == int(exponent) else base ** exponent\n",
    "    \n",
    "    @staticmethod\n",
    "    def factorial(n: int) -> int:\n",
    "        if n == 0:\n",
    "            return 1\n",
    "        result = 1\n",
    "        for i in range(1, n + 1):\n",
    "            result *= i\n",
    "        return result\n",
    "    \n",
    "    @staticmethod\n",
    "    def sine(x: float) -> float:\n",
    "        return x - (x**3)/6 + (x**5)/120 - (x**7)/5040\n",
    "    \n",
    "    @staticmethod\n",
    "    def cosine(x: float) -> float:\n",
    "        return 1 - (x**2)/2 + (x**4)/24 - (x**6)/720\n",
    "    \n",
    "    @staticmethod\n",
    "    def logarithm(x: float, base: float = 2.718) -> float:\n",
    "        n = 10000.0\n",
    "        return n * ((x ** (1/n)) - 1)\n",
    "    \n",
    "# Example Usage\n",
    "data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n",
    "mani = Mani(data)\n",
    "print(\"Mean:\", mani.mean(data))\n",
    "print(\"Standard Deviation:\", mani.standard_deviation(data))\n",
    "print(\"Factorial of 5:\", mani.factorial(5))\n",
    "print(\"Sine of 0.5:\", mani.sine(0.5))\n",
    "print(\"Cosine of 0.5:\", mani.cosine(0.5))\n",
    "print(\"Logarithm of 10:\", mani.logarithm(10))\n",
    "print(\"Normal Distribution:\", mani.normal_distribution(0, 1, 5))\n",
    "print(\"Hypothesis Function:\", mani.hypothesis([0.5, 1.5], [[1, 2], [3, 4]]))\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
